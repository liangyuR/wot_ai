<!-- da8a2687-9a2f-4c74-99f5-6e6ab88ba3e8 88899769-4cf6-45ce-bb11-82cf20132fdb -->
# 路径规划与导航模块实现计划

## 模块结构（分层架构）

在 `yolo` 目录下创建 `path_planning` 模块，采用分层架构：

```
yolo/path_planning/
├── __init__.py
├── core/                    # 核心算法逻辑（无 I/O 依赖）
│   ├── __init__.py
│   ├── minimap_detector.py  # 模块1：小地图识别
│   ├── map_modeler.py       # 模块2：地图建模
│   ├── path_planner.py      # 模块3：路径规划（A*）
│   └── position_smoother.py # 位置平滑器
├── service/                 # 对外服务封装（带屏幕捕获、输入控制）
│   ├── __init__.py
│   ├── capture_service.py  # 屏幕截取服务
│   └── control_service.py  # 鼠标键盘控制服务
├── controller/
│   ├── __init__.py
│   └── path_planning_controller.py  # 主控制器
├── utils/
│   ├── __init__.py
│   └── logger.py           # 统一日志管理
├── visual_debugger.py      # 可视化调试工具
├── config/
│   └── path_planning_config.yaml  # 配置文件
└── train/
    ├── train_minimap.py    # 小地图检测模型训练脚本
    └── prepare_dataset.py  # 数据集准备工具
```

## 实现细节

### 1. 小地图识别模块 (minimap_detector.py)

**功能**：

- 截取屏幕右下角小地图区域
- 使用 YOLO 检测小地图中的元素
- 输出检测结果（我方位置、旗帜位置、障碍物等）

**类设计**：

- `MinimapDetector`: 小地图检测器
  - `__init__(self, model_path, minimap_region, base_dir)`
  - `LoadModel(self) -> bool`
  - `ExtractMinimap(self, frame) -> np.ndarray`: 提取小地图区域
  - `Detect(self, frame) -> dict`: 检测并返回结构化结果
  - `ParseDetections(self, detections) -> dict`: 解析检测结果

**检测类别映射**：

```python
CLASS_MAPPING = {
    0: 'minimap_self',
    1: 'minimap_ally',
    2: 'minimap_enemy',
    3: 'flag_base',
    4: 'minimap_obstacle',
    5: 'minimap_road'
}
```

**输出格式**：

```python
{
    'self_pos': (x, y) or None,
    'flag_pos': (x, y) or None,
    'obstacles': [(x1, y1, x2, y2), ...],
    'roads': [(x1, y1, x2, y2), ...]
}
```

### 2. 地图建模模块 (map_modeler.py)

**功能**：

- 将检测结果转换为二维栅格地图
- 标记可通行和不可通行区域
- 提供地图查询接口

**类设计**：

- `MapModeler`: 地图建模器
  - `__init__(self, grid_size: tuple)`: grid_size = (width, height)
  - `BuildGrid(self, detections: dict) -> np.ndarray`: 构建栅格地图
  - `IsObstacle(self, x: int, y: int) -> bool`: 检查是否为障碍
  - `GetStartPos(self) -> tuple`: 获取起点（我方位置）
  - `GetGoalPos(self) -> tuple`: 获取终点（旗帜位置）
  - `GetGrid(self) -> np.ndarray`: 获取栅格地图

**栅格地图**：

- 0 = 可通行
- 1 = 不可通行（障碍物）
- 默认尺寸：256x256（可配置）

### 3. 路径规划模块 (path_planner.py)

**功能**：

- 定义路径规划策略接口（支持扩展多种算法）
- 实现 A* 算法进行路径规划
- 路径平滑化处理
- 输出从起点到终点的坐标序列

**接口设计（策略模式）**：

- `BasePlanner`: 路径规划器基类（抽象接口）
  - `Plan(self, grid: np.ndarray, start: tuple, goal: tuple) -> List[tuple]`: 抽象方法

- `AStarPlanner(BasePlanner)`: A* 算法实现
  - `__init__(self)`
  - `Plan(self, grid, start, goal) -> List[tuple]`: 实现 A* 规划
  - `AStar(self, grid, start, goal) -> List[tuple]`: A* 核心算法
  - `Heuristic(self, a: tuple, b: tuple) -> float`: 启发式函数（曼哈顿距离）
  - `SmoothPath(self, path: List[tuple], weight: float = 0.3) -> List[tuple]`: 路径平滑化

**A* 算法要点**：

- 使用 heapq 实现优先队列
- 四方向移动：[(1,0), (-1,0), (0,1), (0,-1)]
- 启发式函数：曼哈顿距离
- 路径平滑：移动平均平滑，去除锯齿状路径
- 返回路径坐标列表，无路径时返回空列表

**扩展性**：

- 预留 `DijkstraPlanner`、`RRTPlanner` 等接口，后续可轻松扩展

### 4. 导航执行模块 (navigation_executor.py)

**功能**：

- 将路径转换为游戏操作（鼠标移动、键盘控制）
- 控制角色移动和转向

**类设计**：

- `NavigationExecutor`: 导航执行器
  - `__init__(self, mouse_sensitivity: float, calibration_factor: float)`
  - `ExecutePath(self, path: List[tuple], current_pos: tuple) -> None`: 执行路径
  - `RotateToward(self, target_pos: tuple, current_pos: tuple) -> None`: 转向目标
  - `MoveForward(self, duration: float) -> None`: 前进
  - `UpdatePosition(self) -> tuple`: 更新当前位置（需从检测器获取）

**控制逻辑**：

- 使用 pynput 控制键盘和鼠标
- 计算角度差并控制鼠标转向
- W 键前进，根据距离控制持续时间

### 5. 配置文件 (path_planning_config.yaml)

**配置项**：

```yaml
minimap:
  region:  # 小地图区域（右下角）
    x: 1600    # 起始X坐标
    y: 800     # 起始Y坐标
    width: 320 # 宽度
    height: 320 # 高度
  grid_size: [256, 256]  # 栅格地图尺寸

model:
  path: "train/model/minimap_yolo.pt"  # 小地图检测模型路径
  classes: 6  # 类别数量

navigation:
  mouse_sensitivity: 1.0
  calibration_factor: 150.0
  move_speed: 1.0  # 移动速度系数
  rotation_smooth: 0.3  # 转向平滑系数
```

### 6. 主控制器集成

**文件**：`yolo/path_planning/path_planning_controller.py`

**功能**：

- 整合四个子模块
- 提供统一的运行接口
- 管理运行状态

**类设计**：

- `PathPlanningController`: 路径规划控制器
  - `__init__(self, config_path: Path)`
  - `Start(self) -> None`: 启动路径规划
  - `Stop(self) -> None`: 停止
  - `IsRunning(self) -> bool`: 运行状态
  - `Run(self) -> None`: 主循环

**主循环流程**：

1. 截取屏幕
2. 检测小地图
3. 构建地图模型
4. 规划路径
5. 执行导航
6. 循环更新

## 代码规范

- 遵循 Google C++ 风格
- Public 方法使用大驼峰：`LoadModel()`, `ExecutePath()`
- Private 方法使用小驼峰：`parseDetections()`, `buildGrid()`
- 成员变量末尾加下划线：`model_`, `config_`, `grid_`

## 依赖关系

- 复用现有 `DetectionEngine`（或创建专门的小地图检测器）
- 使用 `pynput` 进行键盘鼠标控制（已存在）
- 使用 `mss` 进行屏幕捕获（已存在）
- 使用 `numpy` 进行数组操作