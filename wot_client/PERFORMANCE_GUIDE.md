# 录制性能优化指南

## 问题诊断

### 症状：录制时卡顿，但 CPU/内存占用不高

这是典型的 **磁盘 I/O 瓶颈**问题！

**原因**：
- 实时保存帧需要持续写入磁盘
- 30 FPS × 250 KB/帧 = **7.5 MB/s** 持续写入
- 机械硬盘或慢速 USB 无法跟上
- JPEG 编码也需要时间（每帧 10-20ms）

## 🚀 解决方案

### 1. 异步帧保存器（已自动启用）✅

**v0.3.1 新功能**：使用独立线程异步保存帧，避免阻塞主录制循环。

**工作原理**：
```
捕获帧 → 添加到队列（<1ms）→ 继续捕获
              ↓
        后台线程保存到磁盘
```

**优势**：
- 主循环不再等待磁盘写入
- 可缓冲 2 秒的帧（60 帧队列）
- 平滑性能波动

**监控队列状态**：
```
录制中... 帧数: 150, 时长: 5.0s, FPS: 30.0, 队列: 3/60
```
- `队列: 3/60` 表示队列中有 3 帧等待保存
- 如果队列接近满（如 50/60），说明磁盘速度不够

### 2. 降低 JPEG 质量

**命令行**（即将添加）：
```bash
python record_main.py --jpeg-quality 85
```

**效果**：
| 质量 | 文件大小 | 编码时间 | 视觉质量 |
|------|---------|---------|---------|
| 95（默认） | 250 KB | 15 ms | 极好 |
| 85 | 150 KB | 10 ms | 优秀 |
| 75 | 100 KB | 8 ms | 良好 |

**建议**：
- 训练用：85 质量足够
- 演示用：95 质量

### 3. 增加帧采样间隔

```bash
# 每 5 帧保存一次
python record_main.py --frame-step 5
```

**效果**：
- 磁盘写入降低 80%
- 内存占用降低
- 仍然记录所有操作（actions.json）

**适用场景**：
- 数据分析
- 动作较慢的游戏
- 磁盘空间有限

### 4. 降低录制帧率

```bash
# 降低到 20 FPS
python record_main.py --fps 20
```

**效果**：
- 捕获负载降低 33%
- 磁盘写入降低 33%

**适用场景**：
- 回合制游戏
- 策略游戏

### 5. 使用更快的存储

**推荐顺序**：
1. ✅ **NVMe SSD**（最佳）- 写入速度 500+ MB/s
2. ✅ **SATA SSD** - 写入速度 200+ MB/s
3. ⚠ **7200 RPM 硬盘** - 可能勉强够用
4. ❌ **5400 RPM 硬盘** - 不推荐
5. ❌ **USB 2.0 驱动器** - 不推荐

**检查当前磁盘**：
```bash
python test_disk_performance.py
```

## 🔍 性能测试

### 测试磁盘速度

```bash
python test_disk_performance.py
```

**示例输出**：
```
测试 JPEG 质量 95...
  编码时间: 12.3 ms
  文件大小: 245.8 KB
  写入帧数: 287
  平均 FPS: 28.7
  写入速度: 6.85 MB/s
  ✓ 性能充足（目标 30 FPS）
```

**判断标准**：
- FPS ≥ 30：✓ 性能充足
- FPS 20-30：⚠ 性能勉强
- FPS < 20：❌ 性能不足

### 实时监控队列

录制时观察日志：
```
录制中... 帧数: 150, 时长: 5.0s, FPS: 30.0, 队列: 3/60
```

**队列状态分析**：
- `0-10/60`：✓ 磁盘速度充足
- `10-30/60`：⚠ 磁盘接近瓶颈
- `30-60/60`：❌ 磁盘严重不足，即将丢帧
- 出现 `丢弃帧` 警告：❌ 队列已满

## 📊 性能对比

### 同步 vs 异步保存

| 指标 | 同步保存（旧） | 异步保存（新） |
|------|-------------|-------------|
| 主循环阻塞 | 每帧 15-20ms | <1ms |
| 帧率稳定性 | 波动大 | 平滑 |
| 磁盘要求 | 严格 | 宽松 |
| 丢帧风险 | 高 | 低（有缓冲） |

### 不同配置的资源占用

| 配置 | 磁盘写入 | CPU 占用 | 推荐场景 |
|------|---------|---------|---------|
| 默认（30 FPS, Q95, step=1） | 7.5 MB/s | ~15% | SSD + 高质量 |
| 优化 1（30 FPS, Q85, step=1） | 4.5 MB/s | ~12% | SSD + 节省空间 |
| 优化 2（30 FPS, Q95, step=5） | 1.5 MB/s | ~10% | HDD + 数据分析 |
| 优化 3（20 FPS, Q85, step=1） | 3.0 MB/s | ~10% | HDD + 慢节奏游戏 |

## 🛠️ 故障排查

### 问题 1：仍然卡顿

**检查队列状态**：
- 如果队列持续接近满 → 磁盘太慢
- 如果队列正常但仍卡顿 → CPU 瓶颈（屏幕捕获慢）

**解决方案**：
1. 降低 JPEG 质量：`--jpeg-quality 75`
2. 增加帧采样：`--frame-step 5`
3. 降低 FPS：`--fps 20`
4. 使用 C++ 加速捕获：`build_xmake.bat`

### 问题 2：出现"丢弃帧"警告

**原因**：队列已满，磁盘保存速度跟不上捕获速度

**解决方案**（按优先级）：
1. **立即**：增加帧采样（`--frame-step 2`）
2. 降低 JPEG 质量（`--jpeg-quality 85`）
3. 更换到更快的磁盘（SSD）
4. 降低 FPS（`--fps 25`）

### 问题 3：录制完成后等待很久

**原因**：异步保存队列中还有很多帧未保存

**正常现象**：
```
等待异步保存队列清空...
队列已清空
异步保存统计: 已保存=287, 丢弃=0
```

**如果等待超过 30 秒**：
- 磁盘可能出现问题
- 检查磁盘空间是否不足
- 检查是否有防病毒软件干扰

### 问题 4：部分帧没有保存

**检查统计信息**：
```
异步保存统计: 已保存=285, 丢弃=2
```

**如果 `丢弃 > 0`**：
- 说明队列溢出了
- 参考"问题 2"的解决方案

## 💡 最佳配置推荐

### 场景 1：高质量训练数据（SSD）
```bash
python record_main.py --fps 30 --save-format frames --frame-step 1
# JPEG 质量: 95（默认）
# 磁盘需求: SSD
# 存储: ~450 MB/分钟
```

### 场景 2：标准训练数据（SSD）
```bash
python record_main.py --fps 30 --save-format frames --frame-step 1 --jpeg-quality 85
# 磁盘需求: SSD
# 存储: ~270 MB/分钟
```

### 场景 3：节省存储（SSD/HDD）
```bash
python record_main.py --fps 30 --save-format frames --frame-step 5 --jpeg-quality 85
# 磁盘需求: SATA SSD 或 HDD
# 存储: ~54 MB/分钟
```

### 场景 4：低性能系统（HDD）
```bash
python record_main.py --fps 20 --save-format frames --frame-step 2 --jpeg-quality 75
# 磁盘需求: HDD
# 存储: ~60 MB/分钟
```

## 📈 性能监控

### 实时监控

录制时观察日志中的关键指标：

```
录制中... 帧数: 150, 时长: 5.0s, FPS: 30.0, 队列: 3/60
              ↑              ↑          ↑         ↑
           捕获帧数        时长      实际FPS    队列状态
```

**健康指标**：
- ✓ 实际 FPS 接近目标 FPS
- ✓ 队列 < 20/60
- ✓ 无丢帧警告

**问题指标**：
- ❌ 实际 FPS 远低于目标
- ❌ 队列 > 40/60
- ❌ 出现丢帧警告

### 录制后验证

```bash
python test_session_format.py
```

检查 `已保存帧` 是否与预期一致。

## 🎓 理解异步保存

### 工作流程

```
主线程（捕获）                后台线程（保存）
    |                             |
捕获帧 ────────┐                  |
    |         │                  |
编码操作       │  添加到队列        从队列取帧
    |         └─────────→        |
    |                         保存到磁盘
    |                             |
继续捕获                       等待下一帧
```

### 队列缓冲

队列可容纳 60 帧（2 秒）：

```
队列: [F1][F2][F3][ ][ ]...[ ]  3/60
              ↑              ↑
           正在保存        空余空间
```

**作用**：
- 平滑短时间的磁盘性能波动
- 避免单次慢速写入影响捕获
- 如果持续跟不上，队列最终会满

### 何时会丢帧

```
队列满时：
[F1][F2][F3]...[F60]  60/60  ← 新帧来了，但队列满了
                              → 丢弃新帧 ⚠
```

## 🔧 高级调优

### 调整队列大小

修改 `record_gameplay.py`：
```python
self.async_saver_ = AsyncFrameSaver(
    frames_dir=self.frames_dir_,
    jpeg_quality=95,
    queue_size=120  # 增加到 4 秒缓冲
)
```

**权衡**：
- 更大队列 = 更平滑，但内存占用更高
- 更小队列 = 省内存，但对磁盘要求更高

### 使用 RAMDisk（极限性能）

**Windows**：
1. 安装 ImDisk 或类似软件
2. 创建 RAMDisk（例如 R: 驱动器，分配 2 GB）
3. 录制到 RAMDisk：
   ```bash
   python record_main.py --output R:\sessions
   ```
4. 录制完成后移动到普通磁盘

**优势**：
- 完全消除磁盘瓶颈
- 支持超高帧率

**风险**：
- 系统崩溃会丢失数据
- 需要足够的内存

## 📝 总结

**问题**：录制卡顿，CPU/内存不高 = 磁盘 I/O 瓶颈

**解决方案**（推荐顺序）：
1. ✅ 已自动启用异步保存器
2. 运行 `python test_disk_performance.py` 诊断
3. 根据结果调整 JPEG 质量或帧采样
4. 如果可能，使用 SSD

**监控**：
- 观察录制时的队列状态
- 检查是否有丢帧警告
- 验证最终保存的帧数

有问题请查看日志或运行诊断工具！

